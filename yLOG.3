.TH yLOG· 3 2008-jul "linux" "interfacing with full library version"

.SH NAME
yLOG \- simple, consistent, and useful process execution debugging

.SH PATRON (see HERITAGE at bottom for more)
clio-chrysafenios (flowering) greek muse of written and oral history

.SH IMAGERY
golden young woman holding a scroll, by a chest full of books

.SH SUMMARY (see yLOG (7) for more information)
yLOG and yLOG_uver allow standardized, structured, and configurable process
execution logging that helps me quickly understand program flow, isolate and
diagnose issues, and therefore, much more quickly fix trouble.

.SH SERIOUS FOREWARNING
i am a crazy, selfish, dog-fooding c-programmer.  my code tends to be
experimental and constantly evolving.  my point is NOT to be the best, it is
to challenge myself, build from scratch, and allow fast problem solving.

.SH DOCUMENTATION
.nf
.B yLOG (3)´´´´´´´´´´´interfacing with yLOG in general
yLOG_long (3)      interfacing with full library, long version
yLOG_short (3)     interfacing with full library, short version
yLOG_error (3)     interfacing with full library, error reporting
yLOG_spec (3)      interfacing with full library, specialty
yLOG_vol (3)       interfacing with full library, volume control
yLOG_unit (3)      interfacing with full library, unit testing
yLOG_uver (3)      interfacing with micro, code-inclusion version
yLOG (6)           interactive usage and navigation of log files
yLOG (7)           decision rationale, scope, and objectives

.SH TABLE OF CONTENTS
.nf  
a) overview        quick summary
b) synopsis        function overview
c) inclusion       bringing the library into your code
d) log files       openning and closing log files

.SH A) OVERVIEW
yLOG is meant to be a permenant part of the source code so that tracing
and debugging may be quickened and improved over time.  my custom makefile
filters out all debugging lines so that a production (no debugging code)
and debugging version (suffixed with _debug) of the program is produced.

yLOG should be used in conjuction with the yURG library which allows debugging
to be categorized and turned on-and-off by those categories, both on the
command line and while running.

.SH B) SYNOPSIS
.nf
usage is noted on the far-left of each entry...
   ! means once-per-program
   Ï every program
   · not in every program

!  char  yLOG_begin    (char* <prog>, char* <location>, char <noise>);
!  char  yLOG_end      (void);

.SH C) INCLUSION

.SS header
a simple header must be included in your shared header file
   #include  <yLOG.h>

.SS library
the library must be added to the make process...
   link to -lyLOG for the production version
   link to -lyLOG_debug for the debugging version (to debug itself)

.SH D) LOG FILES
yLOG (by default) creates specific log files to a dedicated temporary directory which is a
ram-disk, for speed...
   ram-disk /var/log/yLOG/

each log file begins with a timestamp, includes the program name, and uses the
".ulog" suffix.  these files are human readable, 8-bit ascii text.
   YY.MM.DD.hh.mm.ss.program____________________.ulog

.SS char  yLOG_begin (<prog>, <location>, <noise>)
creates a new log file and header (see yLOG (6) for example of output)

.RS 3
.B <program>, used to construct the log file name.
.RE

.RS 3
.B <location>, options for the destination of the file.
.nf
   1) yLOG_STDOUT           stdout                    screen/pipe
   2) yLOG_SYSTEM           /var/log/yLOG/            ram disk
   3) yLOG_HISTORICAL       /var/log/yLOG.historical/ normal disk
   4) yLOG_ROOT             /root/                    normal disk
   5) yLOG_USB              /mnt/usb1/                usb stick
   6) yLOG_NULL             /dev/null/                bitbucket
.RE

.RS 3
.B <noise>, either yLOG_QUIET or yLOG_NOISE
.RE

.SS char  yLOG_end (void)
writes a footer (see yLOG (6) for example) and closes the log.

.SH BUGS
it is incredibly stable for me, but if anyone else used it it might explode
and take the universe with it.

.SH COLOPHON
this page is part of a documentation package meant to make the use of the
heatherly tools easier and faster
